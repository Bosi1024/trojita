% vim: spelllang=en spell textwidth=120
\documentclass[trojita]{subfiles}

\begin{document}

\chapter{IMAP Extensions}
\label{sec:imap-extensions}

\begin{abstract}
  Previous chapter has outlined the generic mode of operation of the IMAP protocol and provided an overview of what
  features are available.  In this chapter, we will talk about how to improve on the basic functionality through the
  optional extensions.
\end{abstract}

It might be concluded from the brief analysis presented in the previous chapter that a few feature of IMAP are rather
limiting in its real-world deployment.  Fortunately, the IMAP protocol includes built-in support of extensions which
allow rather substantial changes to the network communication.

\section{Optimizing the Protocol}

Before dwelling into more advanced topics like improving the synchronization performance or adding new features, let's
have a look at the basic layer of the IMAP protocol and investigate how these affect performance.

\subsection{The LITERAL+ Extension}
\label{sec:imap-literalplus}

One of the lowest-hanging optimization fruit to cater are IMAP's synchronizing literals.  In the basic IMAP, before a
clients proceeds with tasks involving upload of binary data (or any data over a certain size, for that matter), it has
to ask for an explicit server's approval based on the length of the data in question.  As we have shown previously, this
confirmation imposes a full round trip over the network, inducing latency and destroying any potential pipelining
improvements.

The LITERAL+ extension (RFC~2088~\cite{rfc2088}) simply lifts the requirement of having to wait for the server's
continuation requests by a subtle change of the syntax.  Adding an overhead of just one byte, the latency is completely
eliminated and communication gets rapidly streamlined.  We can go as far as to say that the code paths for dealing with
LITERAL+ data are actually simpler than having to deal with the old-fashioned synchronizing literals.  Consider the
following example:

\begin{minted}{text}
  S: * OK
  C: A001 LOGIN {11}
  # The client has to wait for server's response before proceeding any further
  S: + go ahead
  C: FRED FOOBAR {7}
  # A second round-trip wait occurs here
  S: + go ahead
  C: fat man
  S: A001 OK LOGIN completed
\end{minted}

When using the LITERAL+ syntax, the whole interaction happens without having to wait for the server:

\begin{minted}{text}
  S: * OK
  C: A001 LOGIN {11+}
  C: FRED FOOBAR {7+}
  C: fat man
  S: A001 OK LOGIN completed
\end{minted}

Trojitá includes full support for the LITERAL+ extension -- when it detects the {\tt LITERAL+} capability, it will
immediately switch to using non-synchronizing literals for increased performance.

\subsection{Data Compression}

IMAP is a textual, line-based protocol.  As such, it presents extremely good opportunities for compression -- using the
tried DEFLATE algorithm~\cite{rfc1951}, the basic IMAP chatter can be easily compressed to 25~-~40~\% of its original
size~\cite[p. 4]{rfc4978}.

RFC~4978~\cite{rfc4978} provides mechanism for exactly this functionality through the {\tt COMPRESS=DEFLATE} capability.
Trojitá ships with full support for this extension through the permissively licensed {\tt zlib} library.  Unfortunately,
the Qt's {\tt QSslSocket} currently doesn't provide a way to reliably tell whether the SSL connection is already
employing compression.  When combined with IMAP servers hidden behind SSL accelerators or load balancers (i.e. in
situations where the server does not have a clear idea whether the session is already compressed either), this has a
risk of needlessly trying to compress data twice.  This is a limitation in system libraries which cannot be overcome
without resorting to patching system components or conducting non-portable hacks.

\subsection{Improving Security through Cryptography}

RFC~2595~\cite{rfc2595} deals with best practices for establishing SSL/TLS connections to the IMAP server.  Trojitá
follows these recommendations, most notably it tries to establish a secure channel over {\tt STARTTLS} command even
without an explicit action on the user's side, should the server be configured to advertise itself as not accepting
logins over insecure connections through the {\tt LOGINDISABLED} capability.  A manual override is available in
situations where the SSL encryption is not available.

In advent of the recent breaches of many well-known (and widely trusted) Certificate Authorities~\cite{ssl-breaches},
Trojitá also comes with support for SSL key pinning~\cite{ssl-pinning}.  The trust model presented to the user is
similar to handling of SSH servers' public keys with OpenSSH -- upon first connection, the user is always presented with
a choice of whether to accept the certificate or not, along with a confirmation about whether the operating system and
its policy considers the certificate as ``trusted''.  No matter what the system-wide policy says, a changed public key
is always considered a threat and the situation is presented to the user accordingly.

\subsection{The IDLE Mode}
\label{sec:imap-idle}

We have mentioned that even though the protocol requires clients to be ready to accept any responses at any time, in
practice, servers are forbidden to send {\tt EXPUNGE}s when no command is in progress.  This requirement is necessary to
prevent a dangerous resynchronization as the server cannot possibly know whether the client has started to issue an
UID-less {\tt STORE} command which references messages through their sequence numbers.  Unfortunately, this directly
translates to clients having to {\em poll} the server quite often if they care about updates concerning the deleted
messages.

Any protocol which uses polling looks bad on paper -- having to poll leads to increased latency and higher power usage
because the equipment has to actively check for updates every now and then.  In contrast, {\em push-based} updates allow
the client to enter a low-power state where it merely waits to be woken up when a change occurs.  Such a mode is exactly
what the IDLE extension defined by RFC~2177~\cite{rfc2177} adds to IMAP.  It must, however, be said that real-world
concerns related to firewall timeouts and especially the NAT traversal has limited the usefulness of the IDLE command
somewhat, even to the extent where Mark Crispin, the original author of the IMAP protocol, claims that ``I see no
particular benefit to use of IDLE on a desktop machine''~\cite{crispin-idle-useless} -- a view which is not shared by
the wider community~\cite{tss-idle-keepalive} \cite{android-idle}, yet certainly worth a consideration.

The IDLE extension is basically a hack on top of the IMAP protocol which reverses the ``A command is not "in progress"
until the complete command has been received; in particular, a command is not "in progress" during the negotiation of
command continuation.``~\cite[p. 72]{rfc3501} mantra of the basic IMAP specification.  With IDLE, a typical interaction
might look like this one:

\begin{minted}{text}
  C: A004 IDLE
  S: * 2 EXPUNGE
  S: * 3 EXISTS
  S: + idling
  ...time passes; another client expunges message 3...
  S: * 3 EXPUNGE
  S: * 2 EXISTS
  ...time passes; new mail arrives...
  S: * 3 EXISTS
  C: DONE
  S: A004 OK IDLE terminated
  C: A005 FETCH 3 ALL
  S: * 3 FETCH (...)
  S: A005 OK FETCH completed
  C: A006 IDLE
\end{minted}

The whole effect of the {\tt IDLE} command is therefore to indicate to the server that the client is {\em really}
willing to listen for any updates to the mailbox state.  Because of compatibility concerns with legacy mail stores, the
IDLE extension still does {\em not} mandate the server to actually send updates about any changes as soon as they are
conducted -- indeed, a server which internally polls every fifteen minutes to check whether a message has arrived is
fully compliant with the IDLE extension, albeit rather useless to user who might expect (and, we might add, rightly so)
to be {\em instantly} notified about changes to the mailbox.

Trojitá includes full support for the IDLE extension and will enter that mode automatically shortly after a mailbox is
selected.  A simple heuristics is implemented which delays re-entering the IDLE command if it is likely that the
connection will be reused for any other purpose in near future, further eliminating needless data transfers.
Unfortunately, Trojitá is at the mercy of the IMAP server when it comes to superfluous data transfers, so it cannot
prevent the ``pings'' sent even when the connection does not contain a gateway with overly short timeouts.

\section{Improving Mailbox Synchronization}

The previous section dealt with optimizing the overall IMAP protocol as a whole.  At this stage, we can have a look at
more specific issues which cannot be easily overcome through generic measures like data compression using off-the-shelf
algorithms or updates to the basic protocol flows.

In the basic IMAP, neither the server not the client are required to keep any persistent state.  Clearly, it is
beneficiary for a client to keep downloaded copies of the immutable mailbox/message data (consult
\secref{sec:imap-immutable-data} in its persistent cache for some time, should the device constraints allow such a
storage.  There is still quite a lot of other data which has to be validated while the mailbox is being resynchronized.
Consider the following scenario where a mail user agent opens a mailbox with a thousand of message which has witnessed
expunges and new arrivals since the last time it was opened:

\todo[inline]{protocol interaciton demo goes here}

We can identify two steps which substantially contribute to the transferred data:

\begin{itemize}
  \item synchronizing the UIDs,
  \item updating flags.
\end{itemize}

In the rest of this section, we will have a look at optimization opportunities at each of these stages.  Please keep in
mind that some basic optimization heuristics concerning the UID synchronization were discussed in
\secref{sec:imap-mailbox-sync} along with reasons on why these steps are necessary in clients willing to maintain an
offline cache of immutable data.

\subsection{The ESEARCH Extension}

As seen in the protocol sample, the {\tt SEARCH} response containing UIDs of all messages in a mailbox can be rather
large.  At the same time, chances are that at least some of the adjacent messages might have been assigned contiguous
UIDs -- this is certainly not a requirement per se, but quite a few IMAP servers internally {\em do} assign UIDs from a
per-mailbox counter.  Real world, albeit anecdotal evidence \todo{Cannot find a reference right now -- I'd have sworn
that it was in the ``UID Search Responses'' thread on 2007-08-10, but apparently it isn't\ldots I should search for
``three consecutive'' or something like that} indicates that this scenario is very common, and therefore it might make
sense to transmit the UIDs of all messages using the {\tt sequence-set} \cite[p. 89]{rfc3501} syntax.  The ESEARCH
extension, as defined in RFC~4731~\cite{rfc4731}, allows exactly that:

\begin{minted}{text}
  S: * ESEARCH [TAG "y12"] UID 1,3:9,17:25,30:1000
\end{minted}

At the time of the ESEARCH adoption, the imap-protocol mailing list witnessed a disagreement on how exactly the {\tt
sequence-set} shall be interpreted.  Mark Crispin, the author of the original IMAP protocol (but not of the ESEARCH
extension) implemented ESERCH in a different manner.  He chose to take an advantage of the RFC3501-style definition of
UID sequences where the RFC mandates that servers shall treat non-existent UIDs given in sequence sets as if they
weren't referenced from the command at all.  For example, if the mailbox contained just UIDs 3, 5 and 10, a client using
the {\tt 3:10} construct has to be interpreted as if it requested {\tt sequence-set 3,5,10}.  Doing so present certain
optimization opportunities to the servers, for example when the client already knows the UID mapping and performs a
server-side search for messages matching certain criteria {\em and} the result set accurately matches an adjacent range
of messages, the server could take advantage of this adjacency a return a {\tt sequence-set} in the form of {\tt
10:150}, even though the mailbox contains only a few UIDs from this range~\cite{crispin-esearch-flawed}.  Furthermore,
his another point is that the clients already have two other ways of obtaining the UID mapping, either through the {\tt
UID SEARCH ALL} command or via an explicit {\tt UID FETCH 1:*}.  Needless to say, such a reasoning fails to take into
account potential bandwidth savings which can be rather substantial on ``reasonable'' mailboxes.  In the end, the
authors of the RFC 4731 disagreed with Crispin~\cite{daboo-esearch-interpretation}.

The ESEARCH extension allows nice bandwidth savings, so Trojitá tries to use it if the server says that it is supported.
In addition to that, format of the returned responses is changed so that it also includes the tag of the command which
caused it, allowing much more aggressive pipelining -- for example, clients are free to perform the UID discovery at the
same time as running a user-initiated search.  On the other hand, even in presence of ESEARCH, the UID mapping still has
to be synchronized explicitly.  This requirement is only lifted in the QRESYNC extension
(\secref{sec:extension-qresync}).  Before we describe that, though, it is necessary to have a look at the CONDSTORE.

\subsection{Avoiding Flags Resynchronization via CONDSTORE}

Leaving the UID synchronization alone for a while, let's have a look at various ways of eliminating the need to ask for
changed message flags.  In this case, no extension trying to reduce the data overhead of the {\tt FETCH} response was
proposed, but the problem got attacked from another side.

The whole point of flags synchronization is to be able to pick up changes which have happened since the last time was
selected.  If only the server was somehow able to assign a ``serial number'' to each change, we could subsequently ask
for all changes which have happened after a certain point.  The CONDSTORE extension from RFC 4551 \cite{rfc4551} works
in this way.

CONDSTORE-capable servers share a concept of ``modification sequence'', a {\tt MODSEQ}.  Each message in a mailbox is
assigned an unsigned 64bit integer.  Whenever message metadata (like its flags) change, the {\tt MODSEQ} of that
particular message gets increased.  Each increment is also required to reach a value which is higher than {\tt MODSEQ}
of any other message in that mailbox.  Similarly, a mailbox is assigned a {\tt HIGHESTMODSEQ}, an unsigned 64bit integer
which is interpreted as ``no message has ever had a {\tt MODSEQ} higher than this number'' -- of course subject to the
usual {\tt UIDVALIDITY} rules.~\footnote{As always, any change in {\tt UIDVALIDITY} directly translates to a full cache
flush and discarding any data previously remembered for the affected mailbox.  This includes not only the immutable data
of messages, but also the UIDs, message flags and -- in this extension -- the {\tt MODSEQ} and {\tt HIGHESTMODSEQ}
values.}

When a CONDSTORE-capable client opens a mailbox which was previously synced (and if the server supports CONDSTORE as
well, of course -- keep in mind that the IMAP extensions are strictly voluntary in their nature), at first it synces the
UID mapping as usual, possibly through the ESEARCH command discussed earlier.  After that, the client can use an
extended variant of the {\tt FETCH} command to ask for flags of those messages whose {\em current} {\tt MODSEQ} is
higher than the {\tt HIGHESTMODSEQ} which the client has remembered previously.  The server will respond with regular
{\tt FETCH} responses for each affected message.  In result, after this interaction is completed, the client is aware of
all pending flag changes and is fully resynchronized again.

This is how a typical synchronization might look like:

\todo[inline]{Show a CONDSTORE example here}

The algorithm is race-free -- as every message has a separate {\tt MODSEQ} counter, the delay between the {\tt SELECT}
and {\tt FETCH} command doesn't lead to data loss; by the time the {\tt FETCH} completes, the server guarantees that the
client have received any pending updates since the last synchronization.

The CONDSTORE is an extremely valuable extension; its savings on big mailboxes are predictable and automatic -- instead
of having to transmit $O(n)$ responses where $n$ is the number of {\em messages}, only $O(m)$ are required under QRESYNC
with $m$ being the number of {\tt modifications}.  This is an extension which, unfortunately, places a certain burden on
the IMAP server which has to track the serial numbers of messages' metadata; however, given the obvious reductions in
bandwidth, many servers have already implemented it, most notably the Dovecot and Cyrus open source IMAP servers.
Trojitá includes full support for this extension, making use of it whenever it is available.

\subsection{Optimizing UID Synchronization with QRESYNC}
\label{sec:extension-qresync}

The CONDSTORE extension discussed earlier has brought in the concept of a server-side state tracking and used that to
allow bandwidth-efficient way of synchronizing flag changes.  Given that a CONDSTORE-capable server already tracks
certain state, it might be worthwhile to somehow extend this state to cover the deleted messages as well.  As it turns
out, such a mechanism is implemented in the QRESYNC extension which is defined by RFC 5162 \cite{rfc5162}.

The basic idea behind QRESYNC is that as long as the UID mapping was fresh at some point in past, it is only necessary
to inform the client about which UIDs from that set are no longer there and push out the UIDs of newly arrived messages.

The QRESYNC extension modifies the {\tt SELECT command} so that it includes a few more parameters.  First of all, the
updated version of this command includes a tuple of {\tt (UIDNEXT, HIGHESTMODSEQ)} as known to the client.  If the {\tt
UIDNEXT} did not change, the server will have a look at the {\tt HIGHESTMODSEQ} value and in addition to essentially
behaving as a CONDSTORE server, it also sends out a list of expunged messages.~\footnote{Technically, the expunges are
sent out before the information about the updated flags, but that isn't the point here.}  A new response is defined for
this purpose, the {\tt VANISHED EARLIER}.

In format similar to the {\tt ESEARCH} response, the {\tt VANISHED EARLIER} contains a {\tt sequence-set} of UIDs which
the server believes that the client considers to be present in the mailbox.  Not only are these UIDs transmitted in a
compact syntax, thanks to the {\tt sequence-set} format, but the response typically contains only such UIDs which were
{\em just} removed.  The actual wording (and therefore the implications of this extension) are slightly different -- the
server is free to inform the clients about any UIDs, as long as they aren't in the mailbox right now, at the time of the
sync.  This is motivated by the need to relieve the servers from having to maintain a list of expunged UIDs
indefinitely, just in case a QRESYNC-enabled client reconnects after two years of inactivity.  When such a situation
happens, a server which cannot remember expunges going so far in history have no other option but to send a {\tt
VANISHED EARLIER} for {\em all} UIDs lower than the {\tt UIDNEXT}, no matter if they {\em ever} were present in the
mailbox.  This fallback suggests that the QRESYNC extension could very well have a negative net effect overall, at least
in certain pathological situations -- essentially when the list of expunges grows so long that the server decides to
prune some of its records.

In order to mitigate this issue, a few other options were added to QRESYNC.  The first of them is a way of indicating to
the server the range of UIDs about which the client actually cares.  The idea here is that if the client only cached a
subset of messages (for example those with UID higher than 50000), there isn't much point in informing the client about
each and every UID which might had been in the mailbox before (like those 49,999 of UIDs lower than 50,000).

However, chances are that this optimization is not enough to overcome the danger of having to sync too many UIDs -- and
indeed, some user agents might want to preemptively load messages both from the beginning {\em and} from the end of the
mailbox in an effort to optimize preloading.  Such user agents would not be able to benefit from the ``range of known
UIDs'' optimization.

Fortunately, the {\tt SELECT QRESYNC} command includes provisions for passing another type of data around -- it is also
possible to provide a representative list of $(sequence, UID)$ pairs.  Using technique similar to the proposed binary
search when discovering UIDs, the client can decide to send along a UID from roughly middle of the mailbox as the first
one, followed by another one located at circa 75~\% of the mapping, next one from $7 \over 8$ etc., halving the interval
in each step.  The concrete strategy to be pursuit is left to the client, as it is basically a policy decision.  Using
more fine-grained interval means that more data is sent along during each resynchronization without a direct merit (i.e.
when the server {\em still} remembers the previous {\tt HIGHESTMODSEQ} and can provide the client with relevant data),
while on the other hand sending less UIDs leads to minor data savings during ordinary reconnects while causing
potentially huge amounts of data to be transfered when the server is unable to use the -- perhaps very old or otherwise
stale -- {\tt HIGHESTMODSEQ}.

The presented version of Trojitá always uses halving of sequences, effectively transmitting $log_2(n)$ sequence-UID
pairs:

\begin{minted}{c++}
    Sequence knownSeq, knownUid;
    int i = oldUidMap.size() / 2;
    while (i < oldUidMap.size()) {
        // Message sequence number is one-based, our indexes are zero-based
        knownSeq.add(i + 1);
        knownUid.add(oldUidMap[i]);
        i += (oldUidMap.size() - i) / 2 + 1;
    }
\end{minted}

To further reduce the amount of data transmitted during the IMAP session, the QRESYNC extension also introduces a second
kind of the {\tt VANISHED} response -- the one without the {\tt EARLIER} modifier.  Serving as a substitute for the
ordinary {\tt EXPUNGE}, the {\tt VANISHED}'s biggest advantage is that it can inform about multiple expunges in a single
response.  Somewhat ironically, this modification also relieves the clients of their need to maintain a complete
UID-sequence mapping at all times -- but only after providing a method of making this synchronization severely less
painful in the first place.  The whole matter is complicated a bit more by the wording of the RFC which is pretty clear
on that the {\tt VANISHED} responses {\em should} be sent instead of {\tt EXPUNGE} -- a language which, in RFC terms,
means that the servers are supposed to do so, yet the clients are forbidden from relying on such behavior because under
special circumstances, the servers might very well have a good reason to defer back to the {\tt EXPUNGE}~\cite{rfc2119}.

Unfortunately, the combination of offset-based {\tt EXISTS} (which is a response used to inform the client about growth
of the number of messages in a mailbox) with UID-based {\tt VANISHED} can lead to races, a dangerous condition which we
have identified~\cite{kundrat-vanished-race}.  The problem lies in QRESYNC's allowance for non-existent UIDs to be
included in the {\tt VANISHED} response.  Consider the following scenario where the client is fully synced with a
mailbox with just a single message bearing UID 5.  The mailbox' {\tt UIDNEXT} is 11:

\begin{minted}{text}
  S: * 3 EXISTS
  C: x UID FETCH 11:* (FLAGS)
  S: * VANISHED 12:20
\end{minted}

The server is telling the client that any UIDs between 12 and 20 are gone.  The problem is that the client cannot
possibly know whether any message has got any of these particular UIDs, i.e. whether the messages \#2 and \#3 (the first
and second arrival) fall into that range.  Trojitá will immediately send out a request for UIDs of the new arrivals
(that is the {\tt UID FETCH} command in the previous example), but due to the timing issues, it is perfectly possible
that these messages are ``long'' gone (and the appropriate {\tt VANISHED} sent) by the time the server receives the {\tt
UID FETCH} command.  There isn't much a compliant IMAP client can do at this point besides issuing an explicit command
for finding out whether any new messages have actually remained in the mailbox.  This is a minor deficiency in the
QRESYNC extension which could be easily avoided by replacing the {\tt EXISTS} in manner similar to how {\tt EXPUNGE} got
replaced by {\tt VANISHED}.  The previous example would look like this one, eliminating any possibility of races:

\begin{minted}{text}
  S: * ARRIVED 12,33
  C: x UID FETCH 11:* (FLAGS)
  S: * VANISHED 12:20
\end{minted}

The {\tt ARRIVED} command is defined in a proposed draft in \secref{sec:draft-arrived}.  A similar functionality could
be achieved through the NOTIFY extension defined by RFC 5465 \cite{rfc5465}, but supporting NOTIFY is a rather strong
undertaking for an IMAP server and -- as of July 2012 -- support for that extension is still rather
scarce.~\footnote{None of the widely deployed open source IMAP servers supported {\tt NOTIFY} at the time this thesis
was written.  The Dovecot IMAP server had an experimental branch with partial support which would be enough to serve as
a replacement for {\tt ARRIVED}, but it could not be discovered because the {\tt NOTIFY} is an all-or-nothing extension;
it mandates full server support and doesn't include provisions for partial functionality which would have been enough in
this case.}

The QRESYNC extension also mandates an interesting mechanism for its activation.  Allegedly due to the backward
compatibility concerns with the {\tt VANISHED} response, clients have to support the ENABLE extension as well (RFC 5161
\cite{rfc5161}).  However, under a closer examination we can demonstrate that backward compatibility is actually not an
issue here -- compliant clients have to explicitly activate the QRESYNC extension by issuing a specially modified {\tt
SELECT} or {\tt EXAMINE} command, so it appears that using the {\tt ENABLE} command is not really necessary.  In fact,
based on the temporal proximity of RFC 5161 and 5162 (dealing with ENABLE and QRESYNC, respectively) and an overlap in
authorship of these documents, it appears that their designers simply wanted to make use of a mechanism which appeared
to be possibly useful in future.

Unfortunately, there is also a certain uncertainty about the {\tt ENABLE} command --- the errata \#1365 for RFC 5162
\cite{rfc5162-errata} proposes to add an explicit note that ``(A server MUST respond with a tagged BAD
response if) (\ldots) or the server has not positively responded to that command with "ENABLED QRESYNC", in the current
connection'', even though the RFC 5161 explicitly allows for aggressive pipelining of {\tt ENABLE} and {\tt
SELECT}.~\footnote{``There are no limitations on pipelining ENABLE.  For example, it is possible to send ENABLE and then
immediately SELECT, or a LOGIN immediately followed by ENABLE. \cite[p. 2]{rfc5161}}  We have raised this issue on the
{\tt imap-protocol} mailing list and the consensus there was that it is indeed allowed not to wait for the server's {\tt
ENABLED} before issuing a {\tt SELECT \ldots QRESYNC} \cite{melnikov-qresync-enable}.  We fully support such an outcome
as it would be rather awkward to see a requirement for extra network round trips in contemporary IMAP extensions.

\section{Fetching the Data}

\subsection{The BINARY Extension}

\cite{rfc3516}

\subsection{Server-side Conversions via CONVERT}

\cite{rfc5259}

\section{Updating Mailboxes}

\subsection{Sorting, Searching  and Threading}

\cite{rfc5256}
\cite{rfc5957}

\subsection{Incremental Sorting and Searching}

\cite{rfc5267}

\subsection{Refreshing Statistics}

\cite{rfc5465}

\section{Further Improvements}

\subsection{Debugging}

\subsection{Sending Mail}

\end{document}
